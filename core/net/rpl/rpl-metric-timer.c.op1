/*
 * Copyright (c) 2019, KTH Royal Institute of Technology
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * \file
 *         Process for periodic calculation of traffic metric
 * \Author
 *         Voravit Tanyingyong
 */

#include "net/rpl/rpl-metric-timer.h"
#include <string.h>

#define DEBUG DEBUG_NONE
#include "net/ip/uip-debug.h"

#if SINK_ADDITION
#include "dev/slip.h"
#endif
/*---------------------------------------------------------------------------*/
#define UIP_IP_BUF       ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])
#define UIP_ICMP_BUF     ((struct uip_icmp_hdr *)&uip_buf[uip_l2_l3_hdr_len])
#define UIP_ICMP_PAYLOAD ((unsigned char *)&uip_buf[uip_l2_l3_icmp_hdr_len])
/*---------------------------------------------------------------------------*/
PROCESS(rpl_metric_timer_process, "RPL traffic metric process");
static uint8_t started = 0;
/*---------------------------------------------------------------------------*/
uint8_t
status_rpl_metric_timer(void)
{
  return started;
}
/*---------------------------------------------------------------------------*/
void
start_rpl_metric_timer(void)
{
  if(started == 0) {
    process_start(&rpl_metric_timer_process, NULL);
    started = 1;
    PRINTF("rpl_metric_timer_process started\n");
  }
}
/*---------------------------------------------------------------------------*/
void
stop_rpl_metric_timer(void)
{
  if(started == 1) {
    process_exit(&rpl_metric_timer_process);
    started = 0;
    PRINTF("rpl_metric_timer_process stoped\n");
  }
}
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(rpl_metric_timer_process, ev, data)
{

  static struct etimer periodic;
#if (SINK_ADDITION >= 2)
  static uip_ipaddr_t *my_addr;
  char payload[128];
  unsigned char *buffer;
#endif  
#if (SINK_ADDITION == 2)
  static uint8_t count=0;
#endif
#if (SINK_ADDITION == 1)
  static uint8_t count=0;
#if !SINK_FIXED
  static uip_ipaddr_t *my_addr;
  static rpl_rank_t last_sensor_rank = 0;
  static uip_ds6_defrt_t *defrt=NULL;
  rpl_dag_t *dag;
#endif
#endif

  PROCESS_BEGIN();
  PROCESS_PAUSE();

  etimer_set(&periodic, (60*CLOCK_SECOND));
  while(1) {
    PROCESS_WAIT_EVENT();
    if(etimer_expired(&periodic)) {
#if (SINK_ADDITION == 3)
//      count++;
      rpl_calculate_traffic_metric();
      my_addr = rpl_get_src_addr();
      payload[0] = 0x90;
      payload[1] = 0x00;
      payload[2] = 0x02;

      uint32_t tmp;
      tmp = uip_htonl(default_instance->received_traffic);
      memcpy(&payload[3],&tmp,4); 
      tmp = uip_htonl(default_instance->highest_traffic);
      memcpy(&payload[7],&tmp,4); 
      tmp = uip_htonl(slip_get_input_bytes());
      memcpy(&payload[11],&tmp,4); 
      tmp = uip_htonl(slip_get_output_bytes());
      memcpy(&payload[15],&tmp,4); 

      uip_clear_buf();
      buffer = UIP_ICMP_PAYLOAD;
      memcpy(buffer,&payload,19);

#if RPL_CONF_STATS
  RPL_STAT(rpl_stats.dis_ext_out++);
#endif /* RPL_CONF_STATS */
      uip_icmp6_send_src(my_addr, get_coordinator_addr(), ICMP6_RPL, RPL_CODE_DIS, 2+1+4+4+4+4);
#endif /* SINK_ADDITION == 3 */
#if (SINK_ADDITION == 2)
      /* UNCOORDINATED: find a candidate sink  and send activation */
      count++;
      uip_ipaddr_t *target_node = NULL;
      rpl_calculate_traffic_metric();
      if (default_instance != NULL) {
        /* we ignore the first counter since it tends to be over the threshold */
        //if ((count%10)==5) {
        if ((count>1) && (default_instance->received_traffic >= SINK_METRIC_RX_TRAFFIC)) {
        //if ((count>1) && ((default_instance->received_traffic >= SINK_METRIC_RX_TRAFFIC) || 
        //    (default_instance->highest_traffic >= SINK_METRIC_NBR_TRAFFIC))) {
	  /* find sink to activate */
          target_node = activate_sink();

          if (target_node != NULL) {
printf("ACTIVATE: %02x%02x\n", target_node->u8[14], target_node->u8[15]);
	    /* send activation */
            my_addr = rpl_get_src_addr();
            payload[0] = 0xA0;
            payload[1] = 0x00;

            uip_clear_buf();
            buffer = UIP_ICMP_PAYLOAD;
            memcpy(buffer,&payload,2);
#if RPL_CONF_STATS
  RPL_STAT(rpl_stats.dis_ext_out++);
#endif /* RPL_CONF_STATS */
            uip_icmp6_send_src(my_addr, target_node, ICMP6_RPL, RPL_CODE_DIS, 2);
          } else {
            //printf("target_node == NULL\n");
          }
        } else {
          //if ((count>5)&&((count%10)==0)) {
          if (default_instance->received_traffic < (SINK_METRIC_RX_TRAFFIC*SINK_METRIC_THRESHOLD)) {
          //if ((default_instance->received_traffic <= SINK_METRIC_RX_TRAFFIC*SINK_METRIC_THRESHOLD) || 
          //    (default_instance->highest_traffic <= SINK_METRIC_NBR_TRAFFIC*SINK_METRIC_THRESHOLD)) {
	    /* find sink to deactivate */
            target_node = deactivate_sink();

            if (target_node != NULL) {
printf("DEACTIVATE: %02x%02x\n", target_node->u8[14], target_node->u8[15]);
	      /* send deactivation */
              my_addr = rpl_get_src_addr();
              payload[0] = 0xB0;
              payload[1] = 0x00;

              uip_clear_buf();
              buffer = UIP_ICMP_PAYLOAD;
              memcpy(buffer,&payload,2);
#if RPL_CONF_STATS
  RPL_STAT(rpl_stats.dis_ext_out++);
#endif /* RPL_CONF_STATS */
              uip_icmp6_send_src(my_addr, target_node, ICMP6_RPL, RPL_CODE_DIS, 2);
            } else {
              //printf("target_node == NULL\n");
            }
          }
        }

	// Enhancement: activate a sink located far from active sink	
        target_node = activate_high_rank_sink();
        if (target_node != NULL) {
printf("ACTIVATE: %02x%02x\n", target_node->u8[14], target_node->u8[15]);
          my_addr = rpl_get_src_addr();
          payload[0] = 0xA0;
          payload[1] = 0x00;

          uip_clear_buf();
          buffer = UIP_ICMP_PAYLOAD;
          memcpy(buffer,&payload,2);
#if RPL_CONF_STATS
  RPL_STAT(rpl_stats.dis_ext_out++);
#endif /* RPL_CONF_STATS */
          uip_icmp6_send_src(my_addr, target_node, ICMP6_RPL, RPL_CODE_DIS, 2);
        }

      }
#endif /* SINK_ADDITION == 2 */
#if (SINK_ADDITION == 1)
      /* AUTONOMOUS: activate sink functionalities */
      count++;
      rpl_calculate_traffic_metric();
#if !SINK_FIXED
      my_addr = rpl_get_src_addr();
if ((count == (3+10)) && ((my_addr->u8[15]) <= 1)) {
      if (get_operate_mode() == OPERATE_AS_SENSOR) {
        if (default_instance != NULL) {
printf("AUTO ACTIVATION ETX: %u\n", default_instance->current_dag->rank);
	    /* activate sink functionalities */
            dao_output(default_instance->current_dag->preferred_parent, RPL_ZERO_LIFETIME);
            defrt = uip_ds6_defrt_lookup(uip_ds6_defrt_choose());
            if (defrt != NULL) {
              uip_ds6_defrt_rm(defrt);
            }
            printf("%lu ", clock_time());
            printf("ROUTE ADD: ");
            uip_debug_ipaddr_print(rpl_get_src_addr());
            printf("\n");
#ifdef ROOT_VIRTUAL
            uip_ds6_addr_add(get_vr_addr(), 0, ADDR_MANUAL);
#endif
            last_sensor_rank = default_instance->current_dag->rank;
            dag = rpl_set_root(RPL_DEFAULT_INSTANCE, get_vr_addr());
            if(dag != NULL) {
              rpl_set_prefix(dag, get_vr_addr(), 64);
              PRINTF("created a new RPL dag\n");
            }
            set_operate_mode(SINK_ADDITION);
            printf("operate mode: %d\n", get_operate_mode());
            NETSTACK_MAC.off(1);
	} /* default_instance != NULL */
      }
}
if ((count == (3+10+10+1)) && ((my_addr->u8[15]) <= 1)) {
        /* OPERATE_AS_SINK */
      if (get_operate_mode() >= OPERATE_AS_SENSOR) {
        if (default_instance != NULL) {
printf("AUTO DEACTIVATION ETX: %u\n", default_instance->current_dag->rank);
	    /* deactivate sink functionalities */
            default_instance->current_dag->min_rank = last_sensor_rank + RPL_MIN_HOPRANKINC;
            default_instance->current_dag->rank = last_sensor_rank + RPL_MIN_HOPRANKINC;
            rpl_remove_routes(default_instance->current_dag);
            rpl_recalculate_ranks();
            dio_output(default_instance, NULL);

            printf("%lu ", clock_time());
            printf("ROUTE REMOVE: ");
            uip_debug_ipaddr_print(rpl_get_src_addr());
            printf("\n");
  
#ifdef ROOT_VIRTUAL
            uip_ds6_addr_rm(uip_ds6_addr_lookup(get_vr_addr()));
#endif
            rpl_reset_periodic_timer();
            set_operate_mode(OPERATE_AS_SENSOR);
            printf("operate mode: %d\n", get_operate_mode());
            NETSTACK_MAC.on();
        }
      }
}
#endif /* !SINK_FIXED */
#endif /* SINK_ADDITION == 1 */
      etimer_reset(&periodic);
    }
  }

  PROCESS_END();
}
/*---------------------------------------------------------------------------*/
